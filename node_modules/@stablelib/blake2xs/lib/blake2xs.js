"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var blake2s_1 = require("@stablelib/blake2s");
exports.BLOCK_SIZE = blake2s_1.BLOCK_SIZE;
var wipe_1 = require("@stablelib/wipe");
/** Maximum output length */
exports.MAX_DIGEST_LENGTH = 65534;
/** Indicates when ouput length is unknown */
var UNKNOWN_DIGEST_LENGTH = 65535;
function nodeOffsetWithXOFDigestLength(nodeOffset, digestLength) {
    // Node offset is limited to 4 bytes in BLAKE2Xs.
    if (nodeOffset > Math.pow(2, 32) - 1) {
        throw new Error("BLAKE2Xs: node offset " + nodeOffset + " it too big");
    }
    return digestLength * 0x100000000 + nodeOffset;
}
var BLAKE2Xs = (function () {
    /**
     * Creates a new BLAKE2Xs instance with the given digest length. If digest
     * length is not given, it's considered unknown in advance, thus allowing
     * to generate any number of bytes up to 2^32-1.
     */
    function BLAKE2Xs(digestLength, config) {
        if (digestLength === void 0) { digestLength = UNKNOWN_DIGEST_LENGTH; }
        this.digestLength = digestLength;
        this.blockSize = blake2s_1.BLOCK_SIZE;
        this._buf = new Uint8Array(blake2s_1.DIGEST_LENGTH); // output buffer
        this._bufPos = blake2s_1.DIGEST_LENGTH; // position in output buffer, initialized to its end
        this.finish = this.stream;
        if (digestLength <= 0 || digestLength > UNKNOWN_DIGEST_LENGTH) {
            throw new Error("BLAKE2Xs: incorrect digest length");
        }
        var rootConfig = __assign({}, config, { tree: (config && config.tree) ? config.tree : {
                fanout: 1,
                maxDepth: 1,
                leafSize: 0,
                nodeOffset: 0,
                nodeDepth: 0,
                innerDigestLength: 0,
                lastNode: false
            } });
        rootConfig.tree.nodeOffset = nodeOffsetWithXOFDigestLength(rootConfig.tree.nodeOffset, digestLength);
        this._hash = new blake2s_1.BLAKE2s(blake2s_1.DIGEST_LENGTH, rootConfig);
        this._outConfig = __assign({}, rootConfig, { key: undefined, tree: {
                fanout: 0,
                maxDepth: 0,
                leafSize: blake2s_1.DIGEST_LENGTH,
                nodeOffset: nodeOffsetWithXOFDigestLength(0, digestLength),
                nodeDepth: 0,
                innerDigestLength: blake2s_1.DIGEST_LENGTH,
                lastNode: false
            } });
        this._left = digestLength;
    }
    BLAKE2Xs.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) { dataLength = data.length; }
        this._hash.update(data, dataLength);
        return this;
    };
    BLAKE2Xs.prototype.stream = function (dst) {
        if (!this._h0) {
            // Finish root hash to get h0.
            this._h0 = new Uint8Array(blake2s_1.DIGEST_LENGTH);
            this._hash.finish(this._h0);
        }
        if (dst.length === 0) {
            return this;
        }
        if (dst.length > this._left) {
            throw new Error("BLAKE2Xs: cannot generate more bytes");
        }
        for (var i = 0; i < dst.length; i++) {
            if (this._bufPos >= blake2s_1.DIGEST_LENGTH) {
                // Fill buffer.
                var dlen = (this._left < blake2s_1.DIGEST_LENGTH) ? this._left : blake2s_1.DIGEST_LENGTH;
                var h = new blake2s_1.BLAKE2s(dlen, this._outConfig);
                h.update(this._h0);
                h.finish(this._buf);
                h.clean();
                this._bufPos = 0;
                this._outConfig.tree.nodeOffset++;
            }
            dst[i] = this._buf[this._bufPos];
            this._bufPos++;
            this._left--;
        }
        return this;
    };
    BLAKE2Xs.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    BLAKE2Xs.prototype.reset = function () {
        this._hash.reset();
        this._h0 = undefined;
        return this;
    };
    BLAKE2Xs.prototype.clean = function () {
        this._hash.clean();
        wipe_1.wipe(this._buf);
        this._bufPos = 0;
        this.digestLength = 0;
    };
    return BLAKE2Xs;
}());
exports.BLAKE2Xs = BLAKE2Xs;
function xof(digestLength, data, key) {
    var h = new BLAKE2Xs(digestLength, { key: key });
    h.update(data);
    var out = h.digest();
    h.clean();
    return out;
}
exports.xof = xof;
//# sourceMappingURL=blake2xs.js.map