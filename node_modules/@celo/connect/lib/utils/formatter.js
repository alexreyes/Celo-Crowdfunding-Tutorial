"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var address_1 = require("@celo/base/lib/address");
var address_2 = require("@celo/utils/lib/address");
var solidity_1 = require("@celo/utils/lib/solidity");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var utf8_1 = require("utf8");
/**
 * Formats the input of a transaction and converts all values to HEX
 */
function inputCeloTxFormatter(tx) {
    var _a, _b, _c, _d;
    tx.from = inputAddressFormatter((_a = tx.from) === null || _a === void 0 ? void 0 : _a.toString());
    tx.to = inputAddressFormatter(tx.to);
    tx.feeCurrency = inputAddressFormatter(tx.feeCurrency);
    tx.gatewayFeeRecipient = inputAddressFormatter(tx.gatewayFeeRecipient);
    if (tx.data) {
        tx.data = address_1.ensureLeading0x(tx.data);
    }
    if (tx.data && !isHex(tx.data)) {
        throw new Error('The data field must be HEX encoded data.');
    }
    tx.gas = numberToHex(tx.gas);
    tx.gasPrice = numberToHex((_b = tx.gasPrice) === null || _b === void 0 ? void 0 : _b.toString());
    tx.value = numberToHex((_c = tx.value) === null || _c === void 0 ? void 0 : _c.toString());
    // @ts-ignore - nonce is defined as number, but uses as string (web3)
    tx.nonce = numberToHex((_d = tx.nonce) === null || _d === void 0 ? void 0 : _d.toString());
    tx.gatewayFee = numberToHex(tx.gatewayFee);
    // @ts-ignore - prune undefines
    Object.keys(tx).forEach(function (key) { return tx[key] === undefined && delete tx[key]; });
    return tx;
}
exports.inputCeloTxFormatter = inputCeloTxFormatter;
function outputCeloTxFormatter(tx) {
    if (tx.blockNumber !== null) {
        tx.blockNumber = hexToNumber(tx.blockNumber);
    }
    if (tx.transactionIndex !== null) {
        tx.transactionIndex = hexToNumber(tx.transactionIndex);
    }
    tx.nonce = hexToNumber(tx.nonce);
    tx.gas = hexToNumber(tx.gas);
    tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);
    tx.value = outputBigNumberFormatter(tx.value);
    tx.gatewayFee = outputBigNumberFormatter(tx.gatewayFee);
    tx.to =
        tx.to && address_2.isValidAddress(tx.to)
            ? // tx.to could be `0x0` or `null` while contract creation
                (tx.to = address_2.toChecksumAddress(tx.to))
            : null; // set to `null` if invalid address
    if (tx.from) {
        tx.from = address_2.toChecksumAddress(tx.from);
    }
    if (tx.feeCurrency) {
        tx.feeCurrency = address_2.toChecksumAddress(tx.feeCurrency);
    }
    if (tx.gatewayFeeRecipient) {
        tx.gatewayFeeRecipient = address_2.toChecksumAddress(tx.gatewayFeeRecipient);
    }
    return tx;
}
exports.outputCeloTxFormatter = outputCeloTxFormatter;
function outputCeloTxReceiptFormatter(receipt) {
    if (typeof receipt !== 'object') {
        throw new Error('Received receipt is invalid: ' + receipt);
    }
    if (receipt.blockNumber !== null) {
        receipt.blockNumber = hexToNumber(receipt.blockNumber);
    }
    if (receipt.transactionIndex !== null) {
        receipt.transactionIndex = hexToNumber(receipt.transactionIndex);
    }
    receipt.cumulativeGasUsed = hexToNumber(receipt.cumulativeGasUsed);
    receipt.gasUsed = hexToNumber(receipt.gasUsed);
    if (Array.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(outputLogFormatter);
    }
    if (receipt.contractAddress) {
        receipt.contractAddress = address_2.toChecksumAddress(receipt.contractAddress);
    }
    if (typeof receipt.status !== 'undefined' && receipt.status !== null) {
        receipt.status = Boolean(parseInt(address_1.trimLeading0x(receipt.status), 10));
    }
    return receipt;
}
exports.outputCeloTxReceiptFormatter = outputCeloTxReceiptFormatter;
function inputDefaultBlockNumberFormatter(blockNumber) {
    if (blockNumber == null) {
        blockNumber = 'latest';
    }
    return inputBlockNumberFormatter(blockNumber);
}
exports.inputDefaultBlockNumberFormatter = inputDefaultBlockNumberFormatter;
function inputBlockNumberFormatter(blockNumber) {
    if (blockNumber == null) {
        return undefined;
    }
    if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    if (blockNumber === 'genesis') {
        return '0x0';
    }
    return isHexStrict(blockNumber.toString())
        ? blockNumber.toString().toLocaleLowerCase()
        : numberToHex(blockNumber.toString());
}
exports.inputBlockNumberFormatter = inputBlockNumberFormatter;
function outputBlockFormatter(block) {
    // transform to number
    block.gasLimit = hexToNumber(block.gasLimit);
    block.gasUsed = hexToNumber(block.gasUsed);
    block.size = hexToNumber(block.size);
    block.timestamp = hexToNumber(block.timestamp);
    if (block.number !== null) {
        block.number = hexToNumber(block.number);
    }
    if (block.difficulty) {
        block.difficulty = outputBigNumberFormatter(block.difficulty);
    }
    if (block.totalDifficulty) {
        block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);
    }
    if (Array.isArray(block.transactions)) {
        block.transactions.forEach(function (item) {
            if (typeof item !== 'string' && !(item instanceof String)) {
                return outputCeloTxFormatter(item);
            }
        });
    }
    if (block.miner) {
        block.miner = address_2.toChecksumAddress(block.miner);
    }
    return block;
}
exports.outputBlockFormatter = outputBlockFormatter;
function hexToNumber(hex) {
    if (hex) {
        return new bignumber_js_1.default(hex).toNumber();
    }
    return undefined;
}
exports.hexToNumber = hexToNumber;
function outputLogFormatter(log) {
    // generate a custom log id
    if (typeof log.blockHash === 'string' &&
        typeof log.transactionHash === 'string' &&
        typeof log.logIndex === 'string') {
        var shaId = solidity_1.sha3(address_1.trimLeading0x(log.blockHash) +
            address_1.trimLeading0x(log.transactionHash) +
            address_1.trimLeading0x(log.logIndex));
        log.id = 'log_' + address_1.trimLeading0x(shaId).substr(0, 8);
    }
    else if (!log.id) {
        log.id = null;
    }
    if (log.blockNumber !== null) {
        log.blockNumber = hexToNumber(log.blockNumber);
    }
    if (log.transactionIndex !== null) {
        log.transactionIndex = hexToNumber(log.transactionIndex);
    }
    if (log.logIndex !== null) {
        log.logIndex = hexToNumber(log.logIndex);
    }
    if (log.address) {
        log.address = address_2.toChecksumAddress(log.address);
    }
    return log;
}
exports.outputLogFormatter = outputLogFormatter;
function outputBigNumberFormatter(hex) {
    return new bignumber_js_1.default(hex).toString(10);
}
exports.outputBigNumberFormatter = outputBigNumberFormatter;
function inputAddressFormatter(address) {
    if (!address || address === '0x') {
        return undefined;
    }
    if (address_2.isValidAddress(address)) {
        return address_1.ensureLeading0x(address).toLocaleLowerCase();
    }
    throw new Error("Provided address " + address + " is invalid, the capitalization checksum test failed");
}
exports.inputAddressFormatter = inputAddressFormatter;
function inputSignFormatter(data) {
    return isHexStrict(data) ? data : utf8ToHex(data);
}
exports.inputSignFormatter = inputSignFormatter;
function utf8ToHex(str) {
    str = utf8_1.encode(str);
    var hex = '';
    // remove \u0000 padding from either side
    str = str.replace(/^(?:\u0000)*/, '');
    str = str
        .split('')
        .reverse()
        .join('');
    str = str.replace(/^(?:\u0000)*/, '');
    str = str
        .split('')
        .reverse()
        .join('');
    for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        // if (code !== 0) {
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
        // }
    }
    return address_1.ensureLeading0x(hex);
}
function isHex(hex) {
    return /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
}
function isHexStrict(hex) {
    return /^(-)?0x[0-9a-f]*$/i.test(hex);
}
function numberToHex(value) {
    if (value) {
        var numberValue = new bignumber_js_1.default(value);
        var result = address_1.ensureLeading0x(new bignumber_js_1.default(value).toString(16));
        // Seen in web3, copied just in case
        return numberValue.lt(new bignumber_js_1.default(0)) ? "-" + result : result;
    }
    return undefined;
}
function isPredefinedBlockNumber(blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
}
//# sourceMappingURL=formatter.js.map