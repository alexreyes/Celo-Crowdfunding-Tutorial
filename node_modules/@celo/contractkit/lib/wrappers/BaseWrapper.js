"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var address_1 = require("@celo/base/lib/address");
var collections_1 = require("@celo/base/lib/collections");
var connect_1 = require("@celo/connect");
var fixidity_1 = require("@celo/utils/lib/fixidity");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var moment_1 = __importDefault(require("moment"));
/** Base ContractWrapper */
var BaseWrapper = /** @class */ (function () {
    function BaseWrapper(kit, contract) {
        var _this = this;
        this.kit = kit;
        this.contract = contract;
        this.events = this.contract.events;
        this.eventTypes = Object.keys(this.events).reduce(function (acc, key) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[key] = key, _a)));
        }, {});
        this.methodIds = Object.keys(this.contract.methods).reduce(function (acc, method) {
            var methodABI = _this.contract.options.jsonInterface.find(function (item) { return item.name === method; });
            acc[method] =
                methodABI === undefined
                    ? '0x'
                    : _this.kit.connection.getAbiCoder().encodeFunctionSignature(methodABI);
            return acc;
        }, {});
    }
    Object.defineProperty(BaseWrapper.prototype, "address", {
        /** Contract address */
        get: function () {
            return this.contract.options.address;
        },
        enumerable: true,
        configurable: true
    });
    /** Contract getPastEvents */
    BaseWrapper.prototype.getPastEvents = function (event, options) {
        return this.contract.getPastEvents(event, options);
    };
    return BaseWrapper;
}());
exports.BaseWrapper = BaseWrapper;
exports.valueToBigNumber = function (input) { return new bignumber_js_1.default(input); };
exports.fixidityValueToBigNumber = function (input) { return fixidity_1.fromFixed(new bignumber_js_1.default(input)); };
exports.valueToString = function (input) { return exports.valueToBigNumber(input).toFixed(); };
exports.valueToFixidityString = function (input) {
    return fixidity_1.toFixed(exports.valueToBigNumber(input)).toFixed();
};
exports.valueToInt = function (input) {
    return exports.valueToBigNumber(input)
        .integerValue()
        .toNumber();
};
exports.valueToFrac = function (numerator, denominator) {
    return exports.valueToBigNumber(numerator).div(exports.valueToBigNumber(denominator));
};
var TimeDurations;
(function (TimeDurations) {
    TimeDurations[TimeDurations["millennium"] = 31536000000000] = "millennium";
    TimeDurations[TimeDurations["century"] = 3153600000000] = "century";
    TimeDurations[TimeDurations["decade"] = 315360000000] = "decade";
    TimeDurations[TimeDurations["year"] = 31536000000] = "year";
    TimeDurations[TimeDurations["quarter"] = 7776000000] = "quarter";
    TimeDurations[TimeDurations["month"] = 2592000000] = "month";
    TimeDurations[TimeDurations["week"] = 604800000] = "week";
    TimeDurations[TimeDurations["day"] = 86400000] = "day";
    TimeDurations[TimeDurations["hour"] = 3600000] = "hour";
    TimeDurations[TimeDurations["minute"] = 60000] = "minute";
    TimeDurations[TimeDurations["second"] = 1000] = "second";
    TimeDurations[TimeDurations["millisecond"] = 1] = "millisecond";
})(TimeDurations || (TimeDurations = {}));
// taken mostly from https://gist.github.com/RienNeVaPlus/024de3431ae95546d60f2acce128a7e2
function secondsToDurationString(durationSeconds, outputUnits) {
    if (outputUnits === void 0) { outputUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second']; }
    var durationMilliseconds = exports.valueToBigNumber(durationSeconds)
        .times(TimeDurations.second)
        .toNumber();
    if (durationMilliseconds <= 0) {
        return 'past';
    }
    var durations = outputUnits.reduce(function (res, key) {
        var unitDuration = TimeDurations[key];
        var value = Math.floor(durationMilliseconds / unitDuration);
        durationMilliseconds -= value * unitDuration;
        return res.set(key, value);
    }, new Map());
    var s = '';
    durations.forEach(function (value, unit) {
        if (value > 0) {
            s += s !== '' ? ', ' : '';
            s += value + " " + unit + (value > 1 ? 's' : '');
        }
    });
    return s;
}
exports.secondsToDurationString = secondsToDurationString;
exports.blocksToDurationString = function (input) {
    return secondsToDurationString(exports.valueToBigNumber(input).times(5));
}; // TODO: fetch blocktime
exports.unixSecondsTimestampToDateString = function (input) {
    return moment_1.default
        .unix(exports.valueToInt(input))
        .local()
        .format('llll [UTC]Z');
};
exports.stringToSolidityBytes = function (input) { return address_1.ensureLeading0x(input); };
exports.bufferToSolidityBytes = function (input) { return exports.stringToSolidityBytes(address_1.bufferToHex(input)); };
exports.solidityBytesToString = function (input) {
    if (input === null || input === undefined || typeof input === 'string') {
        return input;
    }
    else if (Array.isArray(input)) {
        var hexString = input.reduce(function (acc, num) { return acc + num.toString(16).padStart(2, '0'); }, '');
        return address_1.ensureLeading0x(hexString);
    }
    else {
        throw new Error('Unexpected input type for solidity bytes');
    }
};
/** Identity Parser */
exports.identity = function (a) { return a; };
exports.stringIdentity = function (x) { return x; };
function tupleParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return collections_1.zip(function (parser, input) { return parser(input); }, parsers, args);
    };
}
exports.tupleParser = tupleParser;
function proxyCall() {
    var callArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        callArgs[_i] = arguments[_i];
    }
    if (callArgs.length === 3 && callArgs[1] != null) {
        var methodFn_1 = callArgs[0];
        var parseInputArgs_1 = callArgs[1];
        var parseOutput_1 = callArgs[2];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_1.apply(void 0, parseInputArgs_1.apply(void 0, args)).call()
                .then(parseOutput_1);
        };
    }
    else if (callArgs.length === 3) {
        var methodFn_2 = callArgs[0];
        var parseOutput_2 = callArgs[2];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_2.apply(void 0, args).call()
                .then(parseOutput_2);
        };
    }
    else if (callArgs.length === 2) {
        var methodFn_3 = callArgs[0];
        var parseInputArgs_2 = callArgs[1];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_3.apply(void 0, parseInputArgs_2.apply(void 0, args)).call();
        };
    }
    else {
        var methodFn_4 = callArgs[0];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodFn_4.apply(void 0, args).call();
        };
    }
}
exports.proxyCall = proxyCall;
/**
 * Creates a proxy to send a tx on a web3 native contract method.
 *
 * There are 2 cases:
 *  - call methodFn (no pre or post parsing)
 *  - preParse arguments & call methodFn
 *
 * @param methodFn Web3 methods function
 * @param preParse [optional] preParse function, tranforms arguments into `methodFn` expected inputs
 */
function proxySend(kit) {
    var sendArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sendArgs[_i - 1] = arguments[_i];
    }
    if (sendArgs.length === 2) {
        var methodFn_5 = sendArgs[0];
        var preParse_1 = sendArgs[1];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return connect_1.toTransactionObject(kit.connection, methodFn_5.apply(void 0, preParse_1.apply(void 0, args)));
        };
    }
    else {
        var methodFn_6 = sendArgs[0];
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return connect_1.toTransactionObject(kit.connection, methodFn_6.apply(void 0, args));
        };
    }
}
exports.proxySend = proxySend;
//# sourceMappingURL=BaseWrapper.js.map