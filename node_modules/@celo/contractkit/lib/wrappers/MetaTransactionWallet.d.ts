import { Address } from '@celo/base/lib/address';
import { Signature } from '@celo/base/lib/signatureUtils';
import { CeloTransactionObject, CeloTxObject } from '@celo/connect';
import { EIP712TypedData } from '@celo/utils/lib/sign-typed-data-utils';
import BigNumber from 'bignumber.js';
import { MetaTransactionWallet } from '../generated/MetaTransactionWallet';
import { BaseWrapper } from './BaseWrapper';
export interface TransactionObjectWithValue<T> {
    txo: CeloTxObject<T>;
    value: BigNumber.Value;
}
export interface RawTransaction {
    destination: string;
    value: string;
    data: string;
}
export declare type TransactionInput<T> = CeloTxObject<T> | TransactionObjectWithValue<T> | RawTransaction;
/**
 * Class that wraps the MetaTransactionWallet
 */
export declare class MetaTransactionWalletWrapper extends BaseWrapper<MetaTransactionWallet> {
    /**
     * Execute a transaction originating from the MTW
     * Reverts if the caller is not a signer
     * @param tx a TransactionInput
     */
    executeTransaction(tx: TransactionInput<any>): CeloTransactionObject<string>;
    /**
     * Execute a batch of transactions originating from the MTW
     * Reverts if the caller is not a signer
     * @param txs An array of TransactionInput
     */
    executeTransactions(txs: Array<TransactionInput<any>>): CeloTransactionObject<{
        0: string;
        1: string[];
    }>;
    /**
     * Execute a signed meta transaction
     * Reverts if meta-tx signer is not a signer for the wallet
     * @param tx a TransactionInput
     * @param signature a Signature
     */
    executeMetaTransaction(tx: TransactionInput<any>, signature: Signature): CeloTransactionObject<string>;
    /**
     * Signs a meta transaction as EIP712 typed data
     * @param tx a TransactionWrapper
     * @param nonce Optional -- will query contract state if not passed
     * @returns signature a Signature
     */
    signMetaTransaction(tx: TransactionInput<any>, nonce?: number): Promise<Signature>;
    /**
     * Execute a signed meta transaction
     * Reverts if meta-tx signer is not a signer for the wallet
     * @param tx a TransactionInput
     */
    signAndExecuteMetaTransaction(tx: TransactionInput<any>): Promise<CeloTransactionObject<string>>;
    private getMetaTransactionDigestParams;
    getMetaTransactionDigest: (tx: TransactionInput<any>, nonce: number) => Promise<string>;
    private getMetaTransactionSignerParams;
    getMetaTransactionSigner: (tx: TransactionInput<any>, nonce: number, signature: Signature) => Promise<string>;
    eip712DomainSeparator: () => Promise<string>;
    isOwner: () => Promise<boolean>;
    nonce: () => Promise<number>;
    private getSigner;
    transferOwnership: (newOwner: Address) => CeloTransactionObject<void>;
    setSigner: (newSigner: Address) => CeloTransactionObject<void>;
    setEip712DomainSeparator: () => CeloTransactionObject<void>;
    /**
     * Get and cache the chain ID -- assume it's static for a kit instance
     * @returns chainId
     */
    _chainId?: number;
    private chainId;
    /**
     * Get an cache the signer - it should be static for a Wallet instance
     * @returns signer
     */
    _signer?: Address;
    signer(): Promise<string>;
}
/**
 * Turns any possible way to pass in a transaction into the raw values
 * that are actually required. This is used both internally to normalize
 * ways in which transactions are passed in but also public in order
 * for one instance of ContractKit to serialize a meta transaction to
 * send over the wire and be consumed somewhere else.
 * @param tx TransactionInput<any> union of all the ways we expect transactions
 * @returns a RawTransactions that's serializable
 */
export declare const toRawTransaction: (tx: TransactionInput<any>) => RawTransaction;
/**
 * Turns an array of transaction inputs into the argument that
 * need to be passed to the executeTransactions call.
 * Main transformation is that all the `data` parts of each
 * transaction in the batch are concatenated and an array
 * of lengths is constructed.
 * This is a gas optimisation on the contract.
 * @param txs Array<TransactionInput<any>> array of txs
 * @returns Params for the executeTransactions method call
 */
export declare const toTransactionBatch: (txs: TransactionInput<any>[]) => {
    destinations: string[];
    values: string[];
    callData: string;
    callDataLengths: number[];
};
export declare const buildMetaTxTypedData: (walletAddress: string, tx: RawTransaction, nonce: number, chainId: number) => EIP712TypedData;
